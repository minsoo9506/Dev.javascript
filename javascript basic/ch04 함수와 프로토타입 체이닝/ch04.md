# 4.1 함수 정의
- 함수를 생성하는 방법 : 모두 같은 함수를 생성하지만 함수 동작에서 미묘한 차이존재
  - 함수 선언문 function statement
  - 함수 표현식 function expression
  - `Function()` 생성자 함수

## 4.1.1 함수 리터럴
- 함수리터럴은 크게 4부분
```javascript
function add(x,y) {
    return x+y;
}
```
- function 키워드 
- 함수명 
  - 선택사항이라 함수명이 없는 익명 함수도 가능
- 매개변수 리스트
- 함수몸체
  
## 4.1.2 함수 선언문 방식으로 함수 생성하기
- 함수 리터럴 형태와 같지만
  - 반드시 함수명이 정의되어 있어야 한다

```javascript
function add(x,y) {
    return x+y;
}
```

## 4.1.3 함수 표현식 방식으로 함수 생성하기
- 함수리터럴로 함수를 만들고
  - 여기서 생성된 함수를 변수에 할당하여 함수를 생성

```javascript
var add = function (x,y) {
    return x + y;
}; // 함수표현식에서는 세미콜론으로 끝낸다

var plus = add;

console.log(add(3,4)); // 7
console.log(plus(3,4)); // 7
```
- 위에서 `add` 변수를 함수리터럴로 생성한 함수를 참조하는 변수 (함수변수)
  - 함수 이름이 아니다
- 위처럼 이름이 없는 함수를 익명함수(anonynous function)이라고 한다
- 익명함수는 함수변수에 함수 호출 연산자인 `()` 를 붙여서 사용
  
```javascript
var add = function sum(x,y){
    return x + y;
};

console.log(add(3,4));
console.log(sum(3,4)); // error
// sum is not defined
```
- 위와 같이 이름이 포함된 함수표현식 = 기명 함수 표현식 
- `sum()` 함수호출하면 에러
  - 함수표현식에서 사용된 함수 이름이 외부코드에서 접근 불가능
- 함수표현식에서 함수이름은 선택적
  - 하지만 함수이름을 이용하여 재귀호출 가능

```javascript
var fac = funciton factorial(n) {
    reuturn n * factorial(n-1);
};
```

## 4.1.4 `Function()` 생성자 함수를 통한 함수 생성하기
- 함수리터럴 방식도 내부적으로는 `Function()` 생성자함수로 생성
  - 하지만 생성자함수를 자주 사용 x
  
```javascript
var add = new Function('x','y','return x+y');
```

## 4.1.5 함수 호이스팅
- 함수 표현식만을 사용할 것을 권하고 있는데
  - 이유 중의 하나가 함수 호이스팅 (Function Hoisting)
- 함수 선언문으로 정의한 함수의 유효범위가 코드의 맨 처음부터 시작
  - 아래의 경우처럼 잘 된다
  
```javascript
add(2,3); // 5

function add(x,y) {
    return x+y;
}
```
- 하지만 함수 표현식 방식은 그렇지않다
  - 이게 바람직하다

```javascript
add(2,3); // uncaught type error

var add = function(x,y) {
    return x+y;
};

add(2,3) // 5
```
- 이처럼 함수 호이스팅이 발생하는 원인은
  - 변수생성과 초기화 작업이 분리되서 진행되기 때문 (5장)

# 4.2 함수 객체 : 함수도 객체다

## 4.2.1 자바스크립트에서는 함수도 객체다
- 함수의 기본기능인 코드 실행뿐만 아니라
  - 일반 객체처럼 프로퍼티들을 가질 수 있다
- 함수코드는 함수객체의 '[[Code]] 내부 프로퍼티'에 저장

```javascript
function add(x,y) {
    return x+y;
}

add.result = add(3,2);
add.status = 'good';

console.log(add.result); // 5
console.log(add.status); // good
```

## 4.2.2 자바스크립트에서 함수는 값으로 취급된다
- JS 함수는 다음과 같은 동작이 가능
  - 리터럴에 의해 생성
  - 변수나 배열의 요소, 객체의 프로터티 등에 할당 가능
  - 함수의 인자로 전달 가능
  - 함수의 리턴값으로 리턴 가능
  - 동적으로 프로퍼티를 생성 및 할당 가능
- JS에서는 함수를 일급객체(First Class) 라고 부른다

### 4.2.2.1 변수나 프로퍼티의 값으로 할당
```javascript
// 변수에 함수할당
var bar = function () {return 100;};
console.log(bar()); // 100
// 프로퍼티에 함수할당
var obj = {};
obj.baz = function () {return 100;};
console.log(obj.baz()); // 100
```

### 4.2.2.2 함수 인자로 전달
```javascript
var foo = function(func){
    func();
};

var bar = function () {console.log('hi')};
foo(bar);
```

### 4.2.2.3 리턴값으로 활용
```javascript
var foo = function() {
    return function() {
        console.log('this function is return value')
    };
};

var bar = foo();
bar(); // this function is return value
```

## 4.2.3 함수 객체의 기본 프로퍼티
- 일반 객체와는 다르게 추가로
  - 함수 객체만의 표준 프로퍼티 가 정의
- `length`, `prototype` 프로퍼티를 갖는다
- 이외에도 `name,caller,argument,__proto__` 
- 프로토타입 객체 : Function.prototype

### 4.2.3.1 `length` 프로퍼티
- 함수객체의 `length` 프로퍼티는
  - 함수를 작성할 때 정의한 인자 개수

### 4.2.3.2 `prototype` 프로퍼티
- JS에서는 함수를 생성할 때
  - 함수 자신
  - 그리고 자신과 연결된 프로토타입 객체를 동시 생성
- 함수객체의 `prototype` 프로퍼티는 
  - 함수가 생성될 때 만들어진다
  - 함수객체와 연결된 프로토타입 객체를 참조
- 프로토타입 객체의 프로퍼티는 `constuctor` 만을 가지며
  - `constructor` 는 생성한 함수를 참조

```javascript
function add(x,y) {
    return x+y;
};

console.log(add.prototype);
// 함수객체와 연결된 프로토타입 객체를 참조
console.log(add.prototype.constructor);
// 생성한 함수를 참조, 여기서는 add 함수
```

# 4.3 함수의 다양한 형태
- 익명함수의 대표적인 용도 : 콜백함수
- 콜백함수
  - 개발자는 함수를 등록하기만 하고 어떤 이벤트가 발생한 경우 시스템에서 호출되는 함수 
  - 특정 함수의 인자로 넘겨서, 코드 내부에서 호출되는 함수

```javascript
// 이벤트 핸들러 예제
// window를 키면 alert
window.onload = function() {
    alert('This is the callback funciton');
};
```

## 4.3.2 즉시 실행 함수 (immediate function)
- 함수를 정의함과 동시에 바로 실행하는 함수
- 함수리터럴을 괄호로 둘러싼다 (이름은 상관없다)
- 그리고 바로 호출 될 수 있도록 괄호를 추가한다
  - 필요한 인자가 있을 경우 이 괄호에 넣는다

```javascript
(function(name){
    console.log('This is immediate : ', name);
})('fod');
```
- JS 라이브러리나 프레임워크 소스들에서 사용된다
- 함수 내부에서 정의된 매개변수와 변수들은 코드 내부에서만 유효
  - 전역 네임스페이스를 더럽히지 않을 수 있다

## 4.3.3 내부 함수 (inner function)
- 함수 내부에 정의된 함수
- 클로저를 생성하거나 (5장에서 자세히)
- 부모 함수 코드에서 외부에서의 접근을 막고 독립적인 헬퍼함수를 구현하는 용도 등 

```javascript
function parent () {
    var a = 100;
    var b = 200;

    function child () {
        var b = 300;
    
        console.log(a);
        console.log(b);
    }
    child();
}

parent();
// 100
// 300
child();
// Uncaught ReferenceError: child is not defined
```
- 내부 함수에서는 자신을 둘러싼 부모 함수의 변수에 접근이 가능
- 내부 함수는 일반적으로 자신이 정의된 부모 함수 내부에서만 호출 가능

```javascript
function parent() {
    var a = 100;

    var child = function() {
        console.log(a);
    };

    return child;
}

var inner = parent();
inner(); // 100
```
- 내부함수를 return 값으로 지정하였다
- `inner` 변수가 `child()` 내부 함수를 참조
- `parent()` 같은 부모함수 스코프의 변수를 참고하는 `inner()`와 같은 함수 : 클로저
  
## 4.3.4 함수를 리턴하는 함수
- 이를 이용하여
  - 함수를 호출함과 동시에 다른 함수로 바꾸거나
  - 자기 자신을 재정의하는 함수를 구현할 수 있다

```javascript
var self = function() {
    console.log('a');
    return function() {
        console.log('b');
    }
}
self = self();
self();
// a
// b
```

# 4.4 함수 호출과 this

## 4.4.1 araguments 객체
- 함수를 호출할 때 함수형식에 맞춰 인자를 넘기지 않더라도 에러가 발생하지 않는다

 ```javascript
function func(arg1, arg2) {
    console.log(arg1, arg2);
}

func();      // undefined undefined
func(1);     // 1, undefined
func(1,2);   // 1, 2
func(1,2,3); // 1, 2
 ```
- arguments 객체
  - 함수를 호출할 때 넘긴 인자들이 배열 형태로 저장된 객체
    - 실제 배열이 아닌 유사 배열 객체
  - `console.dir` 을 통해 살펴보면 argument객체는 3부분
    - 함수를 호출할 때 넘겨진 인자 (배열 형태)
    - length 프로퍼티 : 호출시 넘겨진 인자의 개수
    - callee 프로퍼티 : 현재 실행중인 함수의 참조값 (아래에서는 `add()` 함수)

```javascript
function add(a, b) {
    console.dir(arguments);
    return a+b;
}

console.log(add(1));
console.log(add(1,2));
console.log(add(1,2,3));
```
- 매개변수 개수가 정확하게 정해지지 않은 함수를 구현하거나
- 전달된 인자의 개수에 따라 서로 다른 처리를 해줘야하는 함수 개발에 유용

```javascript
function sum() {
    var result = 0;
    for(var i = 0; i < arguments.length; i++){
        result += arguments[i];
    }
    return result;
}

console.log(sum(1,2,3));
console.log(sum(1,2,3,4,5,6,7));
```
